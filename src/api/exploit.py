from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from common.utils import get_logger
from exploit_automation import ExploitAutomation

router = APIRouter(prefix="/exploit", tags=["Exploit"])
logger = get_logger("exploit_api")

# Инициализация модуля ExploitAutomation
automation = ExploitAutomation(safe_mode=True)

class ScanRequest(BaseModel):
    target_range: str
    safe_mode: bool = True
    concurrency: int = 10

class ExploitRequest(BaseModel):
    target_hosts: list[str]
    safe_mode: bool = True

@router.post("/scan")
def scan_network(req: ScanRequest):
    try:
        # Устанавливаем режим
        automation.safe_mode = req.safe_mode
        results = automation.auto_scan(target_range=req.target_range, concurrency=req.concurrency)
        return {"live_hosts": results.get('live_hosts'), "vulnerabilities": results.get('vulnerabilities')}
    except Exception as e:
        logger.error(f"Error during scan: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/exploit")
def exploit_vulnerabilities(req: ExploitRequest):
    try:
        automation.safe_mode = req.safe_mode
        exploitation_results = automation.auto_exploit(target_hosts=req.target_hosts)
        return {"successful_exploits": exploitation_results.get('successful_exploits')}
    except Exception as e:
        logger.error(f"Error during exploit: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/report")
def generate_report():
    try:
        report_path = automation.report("exploit_report.json")
        return {"report_file": report_path}
    except Exception as e:
        logger.error(f"Error generating report: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e)) 