#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
C1 Exploit Integration: Модуль для интеграции ExploitAutomation с C1Brain.

Этот модуль обеспечивает взаимодействие между LLM-агентом (C1Brain) и
модулем автоматизации эксплойтов (ExploitAutomation), позволяя агенту
управлять процессом автоматического поиска и эксплуатации уязвимостей.
"""

import os
import sys
import json
import time
import logging
import tempfile
from typing import Dict, List, Any, Optional, Union, Tuple

# Импортируем модуль автоматизации эксплойтов
from src.exploit_automation import ExploitAutomation

class C1ExploitIntegration:
    """Класс для интеграции ExploitAutomation с C1Brain."""
    
    def __init__(self, safe_mode: bool = True):
        """
        Инициализация модуля интеграции.
        
        Args:
            safe_mode: Режим безопасной работы (без реальной эксплуатации).
        """
        # Настраиваем логирование
        self.logger = logging.getLogger("C1ExploitIntegration")
        self.logger.setLevel(logging.INFO)
        handler = logging.FileHandler("c1_exploit_integration.log")
        handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(handler)
        
        # Создаем экземпляр ExploitAutomation
        self.automation = ExploitAutomation(safe_mode=safe_mode)
        self.safe_mode = safe_mode
        
        # Хранение результатов последнего сканирования/эксплуатации
        self.last_scan_results = None
        self.last_exploit_results = None
        
        self.logger.info("C1ExploitIntegration initialized")
    
    def scan_network(self, target_range: str, concurrency: int = 5) -> Dict:
        """
        Сканирует сеть на наличие уязвимостей.
        
        Args:
            target_range: Диапазон целевых IP-адресов (CIDR нотация).
            concurrency: Максимальное количество одновременных потоков.
            
        Returns:
            Словарь с результатами сканирования.
        """
        self.logger.info(f"Scanning network {target_range}")
        
        # Настраиваем параметры
        self.automation.target_range = target_range
        self.automation.concurrency = concurrency
        
        # Запускаем сканирование
        start_time = time.time()
        self.last_scan_results = self.automation.auto_scan()
        scan_time = time.time() - start_time
        
        # Формируем структурированный ответ
        result = {
            "status": "success",
            "scan_time": scan_time,
            "target_range": target_range,
            "summary": {
                "live_hosts": len(self.last_scan_results["live_hosts"]),
                "total_open_ports": sum(len(ports) for ports in self.last_scan_results["open_ports"].values()),
                "total_vulnerabilities": sum(
                    sum(len(vulns) for vulns in host_vulns.values()) 
                    for host_vulns in self.last_scan_results["vulnerabilities"].values()
                ),
                "total_exploits_matched": sum(
                    sum(len(exploits) for exploits in host_exploits.values()) 
                    for host_exploits in self.last_scan_results["exploits_to_run"].values()
                )
            },
            "top_vulnerable_hosts": self._get_top_vulnerable_hosts(3)
        }
        
        self.logger.info(f"Scan completed: found {result['summary']['live_hosts']} hosts with {result['summary']['total_vulnerabilities']} vulnerabilities")
        return result
    
    def exploit_vulnerabilities(self, target_hosts: Optional[List[str]] = None) -> Dict:
        """
        Эксплуатирует найденные уязвимости.
        
        Args:
            target_hosts: Список IP-адресов для эксплуатации.
                         Если не указан, используются все просканированные хосты.
                         
        Returns:
            Словарь с результатами эксплуатации.
        """
        if not self.last_scan_results:
            self.logger.warning("No scan results available. Run scan_network first.")
            return {
                "status": "error",
                "message": "No scan results available. Run scan_network first."
            }
        
        self.logger.info(f"Exploiting vulnerabilities on {len(target_hosts) if target_hosts else 'all'} hosts")
        
        # Запускаем эксплуатацию
        start_time = time.time()
        self.last_exploit_results = self.automation.auto_exploit(target_hosts)
        exploit_time = time.time() - start_time
        
        # Формируем структурированный ответ
        total_successful = sum(
            sum(len(exploits) for exploits in host_exploits.values())
            for host_exploits in self.last_exploit_results["successful_exploits"].values()
        )
        
        result = {
            "status": "success",
            "exploit_time": exploit_time,
            "summary": {
                "total_exploits_attempted": sum(
                    sum(len(exploits) for exploits in host_exploits.values()) 
                    for host_exploits in self.automation.exploits_to_run.values()
                ) if self.automation.exploits_to_run else 0,
                "total_successful_exploits": total_successful,
                "success_rate": total_successful / max(1, sum(
                    sum(len(exploits) for exploits in host_exploits.values()) 
                    for host_exploits in self.automation.exploits_to_run.values()
                ) if self.automation.exploits_to_run else 1)
            },
            "successful_hosts": self._get_successful_exploits(3)
        }
        
        self.logger.info(f"Exploitation completed: {total_successful} successful exploits")
        return result
    
    def generate_report(self, include_details: bool = True) -> Dict:
        """
        Генерирует отчет о результатах сканирования и эксплуатации.
        
        Args:
            include_details: Включать ли подробные данные в отчет.
            
        Returns:
            Словарь с отчетом.
        """
        if not self.last_scan_results:
            self.logger.warning("No scan results available. Run scan_network first.")
            return {
                "status": "error",
                "message": "No scan results available. Run scan_network first."
            }
        
        # Генерируем отчет во временный файл
        with tempfile.NamedTemporaryFile(suffix='.json', delete=False) as temp_file:
            report_path = temp_file.name
        
        report_json = self.automation.report(report_path)
        # Попробуем распарсить JSON, если вернулся строковый результат
        try:
            report_data = json.loads(report_json)
        except Exception:
            report_data = report_json
        
        # Если не нужны подробные данные, упрощаем отчет
        if not include_details:
            # Удаляем детальную информацию по хостам, оставляем только сводку
            simplified_data = {
                "scan_summary": report_data["scan_summary"],
                "hosts_count": len(report_data["hosts"])
            }
            report_data = simplified_data
        
        return {
            "status": "success",
            "report": report_data,
            "report_path": report_path
        }
    
    def set_safe_mode(self, safe_mode: bool) -> Dict:
        """
        Устанавливает режим безопасной работы.
        
        Args:
            safe_mode: True для безопасного режима (без реальной эксплуатации),
                      False для полной функциональности.
        
        Returns:
            Словарь с результатом операции.
        """
        self.safe_mode = safe_mode
        self.automation.set_safe_mode(safe_mode)
        
        self.logger.info(f"Safe mode set to {safe_mode}")
        return {
            "status": "success",
            "safe_mode": safe_mode,
            "message": f"Safe mode {'enabled' if safe_mode else 'disabled'}"
        }
    
    def get_vulnerability_details(self, vuln_id: str) -> Dict:
        """
        Получает подробную информацию о конкретной уязвимости.
        
        Args:
            vuln_id: Идентификатор уязвимости.
            
        Returns:
            Словарь с информацией о уязвимости.
        """
        # Здесь должна быть логика получения информации из базы данных уязвимостей
        # В качестве заглушки возвращаем примерную информацию
        vuln_details = {
            "id": vuln_id,
            "name": f"Vulnerability {vuln_id}",
            "description": f"Description for vulnerability {vuln_id}",
            "severity": "high",
            "references": [
                {"source": "CVE", "id": f"CVE-2023-{vuln_id}"},
                {"source": "OWASP", "id": f"OWASP-{vuln_id}"}
            ]
        }
        
        return {
            "status": "success",
            "vulnerability": vuln_details
        }
    
    def get_exploit_details(self, exploit_id: str) -> Dict:
        """
        Получает подробную информацию о конкретном эксплойте.
        
        Args:
            exploit_id: Идентификатор эксплойта.
            
        Returns:
            Словарь с информацией об эксплойте.
        """
        # Здесь должна быть логика получения информации из базы данных эксплойтов
        # В качестве заглушки возвращаем примерную информацию
        exploit_details = {
            "id": exploit_id,
            "name": f"Exploit {exploit_id}",
            "description": f"Description for exploit {exploit_id}",
            "author": "Unknown",
            "target_vulnerabilities": [f"CVE-2023-{exploit_id}"],
            "reliability": "high",
            "platforms": ["Windows", "Linux"]
        }
        
        return {
            "status": "success",
            "exploit": exploit_details
        }
    
    def _get_top_vulnerable_hosts(self, limit: int = 3) -> List[Dict]:
        """
        Возвращает список наиболее уязвимых хостов.
        
        Args:
            limit: Максимальное количество хостов для возврата.
            
        Returns:
            Список словарей с информацией о хостах.
        """
        if not self.last_scan_results:
            return []
        
        # Считаем количество уязвимостей на каждом хосте
        host_vuln_count = {}
        for host, ports in self.last_scan_results["vulnerabilities"].items():
            count = sum(len(vulns) for vulns in ports.values())
            host_vuln_count[host] = count
        
        # Сортируем хосты по количеству уязвимостей
        sorted_hosts = sorted(host_vuln_count.items(), key=lambda x: x[1], reverse=True)
        
        # Формируем результат
        result = []
        for host, count in sorted_hosts[:limit]:
            # Собираем информацию о сервисах
            services = {}
            if host in self.last_scan_results["detected_services"]:
                services = self.last_scan_results["detected_services"][host]
            
            # Собираем информацию о открытых портах
            open_ports = []
            if host in self.last_scan_results["open_ports"]:
                open_ports = self.last_scan_results["open_ports"][host]
            
            result.append({
                "host": host,
                "vulnerability_count": count,
                "open_ports": open_ports,
                "services": services
            })
        
        return result
    
    def _get_successful_exploits(self, limit: int = 3) -> List[Dict]:
        """
        Возвращает список успешно эксплуатированных хостов.
        
        Args:
            limit: Максимальное количество хостов для возврата.
            
        Returns:
            Список словарей с информацией о хостах.
        """
        if not self.last_exploit_results:
            return []
        
        # Считаем количество успешных эксплойтов на каждом хосте
        host_exploit_count = {}
        for host, ports in self.last_exploit_results["successful_exploits"].items():
            count = sum(len(exploits) for exploits in ports.values())
            if count > 0:
                host_exploit_count[host] = count
        
        # Сортируем хосты по количеству успешных эксплойтов
        sorted_hosts = sorted(host_exploit_count.items(), key=lambda x: x[1], reverse=True)
        
        # Формируем результат
        result = []
        for host, count in sorted_hosts[:limit]:
            # Собираем информацию об успешных эксплойтах
            exploits_info = {}
            if host in self.last_exploit_results["successful_exploits"]:
                for port, exploits in self.last_exploit_results["successful_exploits"][host].items():
                    if exploits:
                        service = self.last_scan_results["detected_services"].get(host, {}).get(port, "unknown")
                        exploits_info[port] = {
                            "service": service,
                            "exploits": [e.get("id", "unknown") for e in exploits]
                        }
            
            result.append({
                "host": host,
                "successful_exploits_count": count,
                "exploits_details": exploits_info
            })
        
        return result
    
    # Функции для интеграции с C1Brain API
    
    def c1_scan_network(self, api_params: Dict) -> Dict:
        """
        Обработчик API для сканирования сети.
        
        Args:
            api_params: Параметры API.
            
        Returns:
            Словарь с результатами операции.
        """
        try:
            target_range = api_params.get("target_range")
            concurrency = api_params.get("concurrency", 5)
            
            if not target_range:
                return {
                    "status": "error",
                    "message": "target_range parameter is required"
                }
            
            return self.scan_network(target_range, concurrency)
        except Exception as e:
            self.logger.error(f"Error in c1_scan_network: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
    
    def c1_exploit_vulnerabilities(self, api_params: Dict) -> Dict:
        """
        Обработчик API для эксплуатации уязвимостей.
        
        Args:
            api_params: Параметры API.
            
        Returns:
            Словарь с результатами операции.
        """
        try:
            target_hosts = api_params.get("target_hosts")
            return self.exploit_vulnerabilities(target_hosts)
        except Exception as e:
            self.logger.error(f"Error in c1_exploit_vulnerabilities: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
    
    def c1_generate_report(self, api_params: Dict) -> Dict:
        """
        Обработчик API для генерации отчета.
        
        Args:
            api_params: Параметры API.
            
        Returns:
            Словарь с результатами операции.
        """
        try:
            include_details = api_params.get("include_details", True)
            return self.generate_report(include_details)
        except Exception as e:
            self.logger.error(f"Error in c1_generate_report: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
    
    def c1_set_safe_mode(self, api_params: Dict) -> Dict:
        """
        Обработчик API для установки безопасного режима.
        
        Args:
            api_params: Параметры API.
            
        Returns:
            Словарь с результатами операции.
        """
        try:
            safe_mode = api_params.get("safe_mode", True)
            return self.set_safe_mode(safe_mode)
        except Exception as e:
            self.logger.error(f"Error in c1_set_safe_mode: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
    
    def c1_get_vulnerability_details(self, api_params: Dict) -> Dict:
        """
        Обработчик API для получения информации о уязвимости.
        
        Args:
            api_params: Параметры API.
            
        Returns:
            Словарь с результатами операции.
        """
        try:
            vuln_id = api_params.get("vuln_id")
            
            if not vuln_id:
                return {
                    "status": "error",
                    "message": "vuln_id parameter is required"
                }
            
            return self.get_vulnerability_details(vuln_id)
        except Exception as e:
            self.logger.error(f"Error in c1_get_vulnerability_details: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
    
    def c1_get_exploit_details(self, api_params: Dict) -> Dict:
        """
        Обработчик API для получения информации об эксплойте.
        
        Args:
            api_params: Параметры API.
            
        Returns:
            Словарь с результатами операции.
        """
        try:
            exploit_id = api_params.get("exploit_id")
            
            if not exploit_id:
                return {
                    "status": "error",
                    "message": "exploit_id parameter is required"
                }
            
            return self.get_exploit_details(exploit_id)
        except Exception as e:
            self.logger.error(f"Error in c1_get_exploit_details: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
    
    def register_c1_tools(self, c1_brain) -> None:
        """
        Регистрирует инструменты в C1Brain.
        
        Args:
            c1_brain: Экземпляр C1Brain.
        """
        # Регистрация инструментов
        tools = [
            {
                "name": "scan_network",
                "description": "Сканирует сеть на наличие уязвимостей",
                "parameters": {
                    "target_range": "Целевая сеть в формате CIDR (например, 192.168.1.0/24)",
                    "concurrency": "Количество одновременных потоков (опционально)"
                },
                "handler": self.c1_scan_network
            },
            {
                "name": "exploit_vulnerabilities",
                "description": "Эксплуатирует найденные уязвимости",
                "parameters": {
                    "target_hosts": "Список IP-адресов для эксплуатации (опционально)"
                },
                "handler": self.c1_exploit_vulnerabilities
            },
            {
                "name": "generate_report",
                "description": "Генерирует отчет о результатах сканирования и эксплуатации",
                "parameters": {
                    "include_details": "Включать ли подробные данные в отчет (опционально)"
                },
                "handler": self.c1_generate_report
            },
            {
                "name": "set_safe_mode",
                "description": "Устанавливает режим безопасной работы",
                "parameters": {
                    "safe_mode": "True для безопасного режима, False для полной функциональности"
                },
                "handler": self.c1_set_safe_mode
            },
            {
                "name": "get_vulnerability_details",
                "description": "Получает подробную информацию о конкретной уязвимости",
                "parameters": {
                    "vuln_id": "Идентификатор уязвимости"
                },
                "handler": self.c1_get_vulnerability_details
            },
            {
                "name": "get_exploit_details",
                "description": "Получает подробную информацию о конкретном эксплойте",
                "parameters": {
                    "exploit_id": "Идентификатор эксплойта"
                },
                "handler": self.c1_get_exploit_details
            }
        ]
        
        # Регистрируем каждый инструмент в C1Brain
        for tool in tools:
            c1_brain.register_tool(
                name=tool["name"],
                description=tool["description"],
                parameters=tool["parameters"],
                handler=tool["handler"]
            )
        
        self.logger.info(f"Registered {len(tools)} tools in C1Brain")

# Пример использования
if __name__ == "__main__":
    integration = C1ExploitIntegration(safe_mode=True)
    
    # Демонстрация работы
    result = integration.scan_network("192.168.1.0/24")
    print("Scan results:", json.dumps(result, indent=2))
    
    if result["summary"]["total_vulnerabilities"] > 0:
        exploit_result = integration.exploit_vulnerabilities()
        print("Exploit results:", json.dumps(exploit_result, indent=2))
        
        report_result = integration.generate_report()
        print("Report generated:", report_result["report_path"]) 