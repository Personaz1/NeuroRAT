#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ExploitAutomation: Модуль для автоматического поиска и эксплуатации уязвимостей.

Этот модуль предоставляет функциональность для автоматического сканирования целей,
обнаружения уязвимостей и их эксплуатации с минимальным вмешательством пользователя.
Модуль использует данные из ExploitEngine и интегрируется с другими сканерами.
"""

import os
import sys
import json
import time
import random
import logging
import threading
import ipaddress
from typing import List, Dict, Any, Tuple, Optional, Union, Set, Callable

# Импортируем существующие модули
from exploit_engine import ExploitEngine
from port_scanner import PortScanner
from host_scanner import HostScanner
from service_detector import ServiceDetector
from vulnerability_scanner import VulnerabilityScanner

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("exploit_automation.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ExploitAutomation")

class ExploitAutomation:
    """Класс для автоматизации поиска и эксплуатации уязвимостей."""
    
    def __init__(self, target_range: Optional[str] = None, 
                 concurrency: int = 5, safe_mode: bool = True):
        """
        Инициализация модуля автоматизации эксплойтов.
        
        Args:
            target_range: Диапазон целевых IP-адресов (CIDR нотация).
            concurrency: Максимальное количество одновременных потоков.
            safe_mode: Режим безопасной работы (без реальной эксплуатации).
        """
        self.target_range = target_range
        self.concurrency = concurrency
        self.safe_mode = safe_mode
        
        # Инициализируем компоненты
        self.exploit_engine = ExploitEngine(safe_mode=safe_mode)
        self.port_scanner = PortScanner()
        self.host_scanner = HostScanner()
        self.service_detector = ServiceDetector()
        self.vulnerability_scanner = VulnerabilityScanner(target=self.target_range or "")
        
        # Хранение результатов сканирования
        self.live_hosts = []
        self.open_ports = {}  # {host: [ports]}
        self.detected_services = {}  # {host: {port: service}}
        self.vulnerabilities = {}  # {host: {port: [vulns]}}
        self.exploits_to_run = {}  # {host: {port: [exploits]}}
        self.successful_exploits = {}  # {host: {port: [success_exploits]}}
        
        logger.info("ExploitAutomation initialized")
    
    def auto_scan(self, target_range: Optional[str] = None) -> Dict:
        """
        Автоматически сканирует диапазон целей и находит уязвимости.
        
        Args:
            target_range: Диапазон целевых IP-адресов (CIDR нотация).
                         Если не указан, используется установленный при инициализации.
                         
        Returns:
            Словарь с результатами сканирования.
        """
        if target_range:
            self.target_range = target_range
        
        if not self.target_range:
            logger.error("Target range not specified")
            raise ValueError("Target range must be specified")
        
        logger.info(f"Starting auto scan on {self.target_range}")
        
        # 1. Сканируем живые хосты
        self._scan_live_hosts()
        
        # 2. Сканируем порты на живых хостах
        self._scan_ports()
        
        # 3. Определяем сервисы на открытых портах
        self._detect_services()
        
        # 4. Ищем уязвимости в обнаруженных сервисах
        self._find_vulnerabilities()
        
        # 5. Подбираем эксплойты для уязвимостей
        self._match_exploits()
        
        # Возвращаем полную информацию
        return {
            "live_hosts": self.live_hosts,
            "open_ports": self.open_ports,
            "detected_services": self.detected_services,
            "vulnerabilities": self.vulnerabilities,
            "exploits_to_run": self.exploits_to_run
        }
    
    def auto_exploit(self, target_hosts: Optional[List[str]] = None) -> Dict:
        """
        Автоматически эксплуатирует найденные уязвимости.
        
        Args:
            target_hosts: Список IP-адресов для эксплуатации.
                         Если не указан, используются все просканированные хосты.
                         
        Returns:
            Словарь с результатами эксплуатации.
        """
        if not target_hosts:
            target_hosts = self.live_hosts
        
        # Проверяем, что у нас есть эксплойты для запуска
        if not self.exploits_to_run:
            logger.warning("No exploits available to run. Run auto_scan first.")
            return {"successful_exploits": {}}
        
        logger.info(f"Starting auto exploitation on {len(target_hosts)} hosts")
        
        # Очищаем предыдущие результаты
        self.successful_exploits = {}
        
        # Запускаем эксплойты для каждого хоста
        for host in target_hosts:
            if host not in self.exploits_to_run:
                continue
                
            self.successful_exploits[host] = {}
            
            for port, exploits in self.exploits_to_run[host].items():
                self.successful_exploits[host][port] = []
                
                for exploit in exploits:
                    if self.safe_mode:
                        logger.info(f"[SAFE MODE] Would run exploit {exploit['id']} against {host}:{port}")
                        # В safe_mode имитируем успешную эксплуатацию некоторых уязвимостей
                        if random.random() < 0.3:  # 30% успех в режиме имитации
                            self.successful_exploits[host][port].append(exploit)
                    else:
                        try:
                            logger.info(f"Running exploit {exploit['id']} against {host}:{port}")
                            result = self.exploit_engine.run_exploit(exploit, host, port)
                            if result.get('success'):
                                logger.info(f"Exploit {exploit['id']} successful against {host}:{port}")
                                self.successful_exploits[host][port].append(exploit)
                        except Exception as e:
                            logger.error(f"Error running exploit {exploit['id']}: {str(e)}")
        
        return {"successful_exploits": self.successful_exploits}
    
    def _scan_live_hosts(self) -> List[str]:
        """Сканирует сеть на наличие живых хостов."""
        logger.info(f"Scanning for live hosts in {self.target_range}")
        self.live_hosts = self.host_scanner.scan_network(self.target_range)
        logger.info(f"Found {len(self.live_hosts)} live hosts")
        return self.live_hosts
    
    def _scan_ports(self) -> Dict[str, List[int]]:
        """Сканирует порты на живых хостах."""
        self.open_ports = {}
        
        for host in self.live_hosts:
            logger.info(f"Scanning ports on {host}")
            ports = self.port_scanner.scan(host)
            self.open_ports[host] = ports
            logger.info(f"Found {len(ports)} open ports on {host}")
        
        return self.open_ports
    
    def _detect_services(self) -> Dict[str, Dict[int, str]]:
        """Определяет сервисы на открытых портах."""
        self.detected_services = {}
        
        for host in self.live_hosts:
            self.detected_services[host] = {}
            if host not in self.open_ports:
                continue
                
            logger.info(f"Detecting services on {host}")
            for port in self.open_ports[host]:
                service = self.service_detector.detect(host, port)
                self.detected_services[host][port] = service
                logger.info(f"Detected service on {host}:{port} - {service}")
        
        return self.detected_services
    
    def _find_vulnerabilities(self) -> Dict[str, Dict[int, List[Dict]]]:
        """Ищет уязвимости на обнаруженных сервисах."""
        self.vulnerabilities = {}
        
        for host in self.live_hosts:
            self.vulnerabilities[host] = {}
            if host not in self.detected_services:
                continue
                
            logger.info(f"Scanning vulnerabilities on {host}")
            for port, service in self.detected_services[host].items():
                vulns = self.vulnerability_scanner.scan(host, port, service)
                self.vulnerabilities[host][port] = vulns
                logger.info(f"Found {len(vulns)} vulnerabilities on {host}:{port}")
        
        return self.vulnerabilities
    
    def _match_exploits(self) -> Dict[str, Dict[int, List[Dict]]]:
        """Подбирает эксплойты для найденных уязвимостей."""
        self.exploits_to_run = {}
        
        for host in self.live_hosts:
            self.exploits_to_run[host] = {}
            if host not in self.vulnerabilities:
                continue
                
            logger.info(f"Matching exploits for {host}")
            for port, vulns in self.vulnerabilities[host].items():
                service = self.detected_services[host].get(port, "unknown")
                
                # Ищем эксплойты на основе уязвимостей и сервиса
                exploits = []
                for vuln in vulns:
                    search_criteria = {
                        "vuln_id": vuln.get('id'),
                        "service": service,
                        "port": port
                    }
                    matched_exploits = self.exploit_engine.search_exploits(search_criteria)
                    exploits.extend(matched_exploits)
                
                # Также ищем эксплойты, специфичные для сервисов
                service_exploits = self.exploit_engine.search_exploits({"service": service})
                exploits.extend(service_exploits)
                
                # Удаляем дубликаты
                unique_exploits = []
                exploit_ids = set()
                for exploit in exploits:
                    if exploit['id'] not in exploit_ids:
                        exploit_ids.add(exploit['id'])
                        unique_exploits.append(exploit)
                
                if unique_exploits:
                    self.exploits_to_run[host][port] = unique_exploits
                    logger.info(f"Matched {len(unique_exploits)} exploits for {host}:{port}")
        
        return self.exploits_to_run
    
    def report(self, output_file: Optional[str] = None) -> str:
        """
        Генерирует подробный отчет о результатах сканирования и эксплуатации.
        
        Args:
            output_file: Путь к файлу для сохранения отчета.
                        Если не указан, отчет возвращается как строка.
                        
        Returns:
            Отчет в виде строки.
        """
        report_data = {
            "scan_summary": {
                "target_range": self.target_range,
                "live_hosts": len(self.live_hosts),
                "total_open_ports": sum(len(ports) for ports in self.open_ports.values()),
                "total_vulnerabilities": sum(
                    sum(len(vulns) for vulns in host_vulns.values()) 
                    for host_vulns in self.vulnerabilities.values()
                ),
                "total_exploits_matched": sum(
                    sum(len(exploits) for exploits in host_exploits.values()) 
                    for host_exploits in self.exploits_to_run.values()
                ),
                "total_successful_exploits": sum(
                    sum(len(exploits) for exploits in host_exploits.values()) 
                    for host_exploits in self.successful_exploits.values()
                ),
            },
            "hosts": {}
        }
        
        # Собираем детальную информацию по хостам
        for host in self.live_hosts:
            host_data = {
                "open_ports": self.open_ports.get(host, []),
                "services": self.detected_services.get(host, {}),
                "vulnerabilities": {},
                "exploits": {},
                "successful_exploits": {}
            }
            
            # Добавляем информацию о уязвимостях
            if host in self.vulnerabilities:
                for port, vulns in self.vulnerabilities[host].items():
                    host_data["vulnerabilities"][port] = [v.get('id', 'unknown') for v in vulns]
            
            # Добавляем информацию о подобранных эксплойтах
            if host in self.exploits_to_run:
                for port, exploits in self.exploits_to_run[host].items():
                    host_data["exploits"][port] = [e.get('id', 'unknown') for e in exploits]
            
            # Добавляем информацию об успешных эксплойтах
            if host in self.successful_exploits:
                for port, exploits in self.successful_exploits[host].items():
                    host_data["successful_exploits"][port] = [e.get('id', 'unknown') for e in exploits]
            
            report_data["hosts"][host] = host_data
        
        # Преобразуем в JSON
        report_json = json.dumps(report_data, indent=2)
        
        # Сохраняем отчет в файл, если указан путь
        if output_file:
            with open(output_file, 'w') as f:
                f.write(report_json)
        
        return report_json
        
    def stop(self) -> None:
        """Останавливает все процессы сканирования и эксплуатации."""
        logger.info("Stopping all scanning and exploitation processes")
        # Здесь можно добавить логику остановки активных процессов
        
    def set_safe_mode(self, safe_mode: bool) -> None:
        """
        Устанавливает режим безопасной работы.
        
        Args:
            safe_mode: True для безопасного режима (без реальной эксплуатации),
                      False для полной функциональности.
        """
        self.safe_mode = safe_mode
        self.exploit_engine.safe_mode = safe_mode
        logger.info(f"Safe mode set to {safe_mode}")

# Пример использования
if __name__ == "__main__":
    # Создаем экземпляр класса с настройками по умолчанию
    automation = ExploitAutomation(safe_mode=True)
    
    # Можно указать целевую сеть при создании экземпляра или при вызове auto_scan
    results = automation.auto_scan("192.168.1.0/24")
    
    # Запускаем автоматическую эксплуатацию уязвимостей
    exploitation_results = automation.auto_exploit()
    
    # Генерируем и сохраняем отчет
    automation.report("exploit_report.json")
    
    print(f"Scan completed. Found {len(results['live_hosts'])} live hosts.")
    print(f"Detected {sum(len(exploits) for host, ports in results['exploits_to_run'].items() for port, exploits in ports.items())} potential exploits.")
    print(f"Successfully exploited {sum(len(exploits) for host, ports in exploitation_results['successful_exploits'].items() for port, exploits in ports.items())} vulnerabilities.") 