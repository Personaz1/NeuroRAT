#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import logging
import requests
import subprocess
import tempfile
import importlib.util
import sys
import time
from typing import Dict, List, Optional, Any, Tuple, Union
from concurrent.futures import ThreadPoolExecutor

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("exploit_engine.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ExploitEngine")

class ExploitEngine:
    """
    Движок для поиска и запуска эксплойтов для обнаруженных уязвимостей
    """
    
    def __init__(self, 
                exploits_dir: str = "exploits",
                cache_dir: str = "cache",
                threads: int = 5,
                timeout: int = 30,
                safe_mode: bool = True):
        """
        Инициализация движка эксплойтов
        
        Args:
            exploits_dir: Директория с локальными эксплойтами
            cache_dir: Директория для кеширования данных
            threads: Количество потоков для параллельного запуска эксплойтов
            timeout: Таймаут для выполнения эксплойта (в секундах)
            safe_mode: Безопасный режим (без реального запуска эксплойтов)
        """
        self.exploits_dir = exploits_dir
        self.cache_dir = cache_dir
        self.threads = threads
        self.timeout = timeout
        self.safe_mode = safe_mode
        
        # Создаем директории если они не существуют
        for directory in [exploits_dir, cache_dir]:
            if not os.path.exists(directory):
                os.makedirs(directory)
                logger.info(f"Создана директория: {directory}")
        
        # Загружаем базу данных эксплойтов
        self.exploits_db = self._load_exploits_database()
        
        # Загружаем базу данных CVE
        self.cve_db = self._load_cve_database()
        
        logger.info(f"ExploitEngine инициализирован. Загружено {len(self.exploits_db)} эксплойтов.")
    
    def _load_exploits_database(self) -> Dict[str, Dict[str, Any]]:
        """
        Загружает базу данных эксплойтов из локальной директории и внешних источников
        
        Returns:
            Словарь с информацией об эксплойтах
        """
        exploits_db = {}
        
        # Загружаем локальные эксплойты
        for root, _, files in os.walk(self.exploits_dir):
            for file in files:
                if file.endswith('.py'):
                    exploit_path = os.path.join(root, file)
                    exploit_info = self._parse_exploit_file(exploit_path)
                    if exploit_info and 'id' in exploit_info:
                        exploits_db[exploit_info['id']] = {
                            **exploit_info,
                            'path': exploit_path
                        }
        
        # Загружаем базу данных из кеша если есть
        cache_path = os.path.join(self.cache_dir, 'exploits_db.json')
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r') as f:
                    cached_db = json.load(f)
                    # Объединяем с локальными эксплойтами, но приоритет у локальных
                    for exploit_id, exploit_info in cached_db.items():
                        if exploit_id not in exploits_db:
                            exploits_db[exploit_id] = exploit_info
                logger.info(f"Загружено {len(cached_db)} эксплойтов из кеша")
            except Exception as e:
                logger.error(f"Ошибка загрузки кеша эксплойтов: {e}")
        
        return exploits_db
    
    def _load_cve_database(self) -> Dict[str, Dict[str, Any]]:
        """
        Загружает базу данных CVE
        
        Returns:
            Словарь с информацией о CVE
        """
        cve_db = {}
        
        # Загружаем базу данных из кеша если есть
        cache_path = os.path.join(self.cache_dir, 'cve_db.json')
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r') as f:
                    cve_db = json.load(f)
                logger.info(f"Загружено {len(cve_db)} CVE из кеша")
            except Exception as e:
                logger.error(f"Ошибка загрузки кеша CVE: {e}")
        
        return cve_db
    
    def _parse_exploit_file(self, file_path: str) -> Optional[Dict[str, Any]]:
        """
        Парсит файл с эксплойтом для извлечения метаданных
        
        Args:
            file_path: Путь к файлу с эксплойтом
            
        Returns:
            Словарь с метаданными эксплойта или None в случае ошибки
        """
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Извлекаем базовую информацию
            exploit_info = {
                'path': file_path,
                'filename': os.path.basename(file_path)
            }
            
            # Ищем идентификатор CVE
            import re
            cve_match = re.search(r'CVE-\d{4}-\d{4,}', content)
            if cve_match:
                exploit_info['id'] = cve_match.group(0)
            else:
                # Если CVE не найден, используем имя файла как ID
                exploit_info['id'] = os.path.splitext(exploit_info['filename'])[0]
            
            # Ищем название
            name_match = re.search(r'(?:name|title|description).*?:\s*["\'](.+?)["\']', content, re.IGNORECASE)
            if name_match:
                exploit_info['name'] = name_match.group(1)
            else:
                exploit_info['name'] = exploit_info['id']
            
            # Ищем описание в комментариях или docstring
            desc_match = re.search(r'"""(.+?)"""', content, re.DOTALL)
            if desc_match:
                exploit_info['description'] = desc_match.group(1).strip()
            else:
                exploit_info['description'] = "Нет описания"
            
            # Определяем тип эксплойта
            if 'rce' in content.lower() or 'remote code execution' in content.lower():
                exploit_info['type'] = 'rce'
            elif 'privilege' in content.lower() or 'escalation' in content.lower():
                exploit_info['type'] = 'privilege_escalation'
            elif 'disclosure' in content.lower() or 'leak' in content.lower():
                exploit_info['type'] = 'info_disclosure'
            else:
                exploit_info['type'] = 'other'
            
            return exploit_info
        except Exception as e:
            logger.error(f"Ошибка парсинга файла {file_path}: {e}")
            return None
    
    def find_exploits_for_service(self, service_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Ищет эксплойты для конкретного сервиса
        
        Args:
            service_info: Информация о сервисе (имя, версия, порт)
            
        Returns:
            Список подходящих эксплойтов
        """
        matching_exploits = []
        
        service_name = service_info.get('name', '').lower()
        service_version = service_info.get('version', '')
        
        for exploit_id, exploit_info in self.exploits_db.items():
            # Проверяем соответствие по имени сервиса
            if service_name in exploit_info.get('description', '').lower() or \
               service_name in exploit_info.get('name', '').lower():
                # Проверяем соответствие по версии если она указана
                if not service_version or service_version in exploit_info.get('description', ''):
                    matching_exploits.append(exploit_info)
        
        return matching_exploits
    
    def find_exploits_for_vulnerability(self, vuln_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Ищет эксплойты для конкретной уязвимости
        
        Args:
            vuln_info: Информация о уязвимости (cve, name, description)
            
        Returns:
            Список подходящих эксплойтов
        """
        matching_exploits = []
        
        # Ищем по CVE если указан
        cve_id = vuln_info.get('cve')
        if cve_id and cve_id in self.exploits_db:
            matching_exploits.append(self.exploits_db[cve_id])
        
        # Ищем по описанию и названию
        vuln_name = vuln_info.get('name', '').lower()
        vuln_desc = vuln_info.get('description', '').lower()
        
        for exploit_id, exploit_info in self.exploits_db.items():
            if cve_id and cve_id in exploit_id:
                # Уже добавили выше
                continue
            
            exploit_desc = exploit_info.get('description', '').lower()
            exploit_name = exploit_info.get('name', '').lower()
            
            if (vuln_name and vuln_name in exploit_desc) or \
               (vuln_name and vuln_name in exploit_name) or \
               (vuln_desc and any(word in exploit_desc for word in vuln_desc.split() if len(word) > 4)):
                matching_exploits.append(exploit_info)
        
        return matching_exploits
    
    def execute_exploit(self, 
                      exploit_info: Dict[str, Any], 
                      target: str,
                      port: Optional[int] = None,
                      options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Выполняет эксплойт против указанной цели
        
        Args:
            exploit_info: Информация об эксплойте
            target: Целевой хост или URL
            port: Порт (если применимо)
            options: Дополнительные параметры для эксплойта
            
        Returns:
            Результат выполнения эксплойта
        """
        result = {
            'exploit_id': exploit_info.get('id'),
            'exploit_name': exploit_info.get('name'),
            'target': target,
            'port': port,
            'success': False,
            'output': '',
            'error': None,
            'timestamp': time.time()
        }
        
        # Логируем информацию о запуске
        logger.info(f"Запуск эксплойта {exploit_info.get('id')} против {target}:{port if port else 'N/A'}")
        
        if self.safe_mode:
            logger.warning("Запуск в безопасном режиме. Эксплойт НЕ будет реально выполнен.")
            result['output'] = "Безопасный режим активирован. Эксплойт не был выполнен."
            return result
        
        # Проверяем, существует ли файл эксплойта
        exploit_path = exploit_info.get('path')
        if not exploit_path or not os.path.exists(exploit_path):
            result['error'] = f"Файл эксплойта не найден: {exploit_path}"
            logger.error(result['error'])
            return result
        
        try:
            # Формируем команду для запуска эксплойта
            cmd = [sys.executable, exploit_path, '--target', target]
            
            if port:
                cmd.extend(['--port', str(port)])
            
            # Добавляем дополнительные опции
            if options:
                for key, value in options.items():
                    if value is True:
                        cmd.append(f'--{key}')
                    elif value is not False and value is not None:
                        cmd.extend([f'--{key}', str(value)])
            
            # Запускаем эксплойт с ограничением по времени
            logger.debug(f"Запуск команды: {' '.join(cmd)}")
            
            with tempfile.TemporaryFile() as stdout_file:
                process = subprocess.Popen(
                    cmd,
                    stdout=stdout_file,
                    stderr=subprocess.STDOUT,
                    text=True
                )
                
                try:
                    process.wait(timeout=self.timeout)
                    stdout_file.seek(0)
                    output = stdout_file.read().decode('utf-8', errors='ignore')
                    
                    result['output'] = output
                    
                    # Анализируем вывод для определения успешности
                    if process.returncode == 0 and ('success' in output.lower() or 'successful' in output.lower()):
                        result['success'] = True
                        logger.info(f"Эксплойт {exploit_info.get('id')} успешно выполнен")
                    else:
                        logger.warning(f"Эксплойт {exploit_info.get('id')} завершился с кодом {process.returncode}")
                    
                except subprocess.TimeoutExpired:
                    process.kill()
                    result['error'] = f"Превышено время ожидания ({self.timeout}с)"
                    logger.warning(result['error'])
            
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"Ошибка при запуске эксплойта {exploit_info.get('id')}: {e}")
        
        return result
    
    def search_exploits(self, query: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Ищет эксплойты по заданным критериям
        
        Args:
            query: Критерии поиска (cve, service, product, version, etc.)
            
        Returns:
            Список найденных эксплойтов
        """
        results = []
        
        # Поиск по CVE
        if 'cve' in query:
            cve_id = query['cve']
            if cve_id in self.exploits_db:
                results.append(self.exploits_db[cve_id])
        
        # Поиск по имени сервиса/продукта
        if 'service' in query or 'product' in query:
            service_name = query.get('service', query.get('product', '')).lower()
            version = query.get('version', '')
            
            for exploit_id, exploit_info in self.exploits_db.items():
                if service_name in exploit_info.get('name', '').lower() or \
                   service_name in exploit_info.get('description', '').lower():
                    if not version or version in exploit_info.get('description', ''):
                        results.append(exploit_info)
        
        # Поиск по типу эксплойта
        if 'type' in query:
            exploit_type = query['type'].lower()
            for exploit_id, exploit_info in self.exploits_db.items():
                if exploit_info.get('type') == exploit_type:
                    if exploit_info not in results:
                        results.append(exploit_info)
        
        # Поиск по ключевым словам
        if 'keywords' in query:
            keywords = [k.lower() for k in query['keywords']]
            for exploit_id, exploit_info in self.exploits_db.items():
                description = exploit_info.get('description', '').lower()
                name = exploit_info.get('name', '').lower()
                
                if any(keyword in description or keyword in name for keyword in keywords):
                    if exploit_info not in results:
                        results.append(exploit_info)
        
        logger.info(f"Найдено {len(results)} эксплойтов по запросу")
        return results
    
    def run_exploit_batch(self, 
                        exploits: List[Dict[str, Any]], 
                        target: str,
                        port: Optional[int] = None,
                        options: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """
        Запускает набор эксплойтов против указанной цели
        
        Args:
            exploits: Список эксплойтов для запуска
            target: Целевой хост или URL
            port: Порт (если применимо)
            options: Дополнительные параметры для эксплойтов
            
        Returns:
            Список результатов выполнения эксплойтов
        """
        results = []
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_exploit = {
                executor.submit(
                    self.execute_exploit, 
                    exploit, 
                    target, 
                    port, 
                    options
                ): exploit for exploit in exploits
            }
            
            for future in future_to_exploit:
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    exploit = future_to_exploit[future]
                    logger.error(f"Ошибка при выполнении эксплойта {exploit.get('id')}: {e}")
                    results.append({
                        'exploit_id': exploit.get('id'),
                        'exploit_name': exploit.get('name'),
                        'target': target,
                        'port': port,
                        'success': False,
                        'output': '',
                        'error': str(e),
                        'timestamp': time.time()
                    })
        
        # Сортируем результаты - сначала успешные
        results.sort(key=lambda x: not x['success'])
        
        return results
    
    def generate_report(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Генерирует отчет на основе результатов выполнения эксплойтов
        
        Args:
            results: Список результатов выполнения эксплойтов
            
        Returns:
            Отчет в виде словаря
        """
        successful = [r for r in results if r['success']]
        failed = [r for r in results if not r['success']]
        
        report = {
            'timestamp': time.time(),
            'total_exploits': len(results),
            'successful_exploits': len(successful),
            'failed_exploits': len(failed),
            'success_rate': len(successful) / len(results) if results else 0,
            'successful': successful,
            'failed': failed
        }
        
        return report
    
    def update_exploits_database(self, force: bool = False) -> bool:
        """
        Обновляет базу данных эксплойтов из внешних источников
        
        Args:
            force: Принудительное обновление, даже если кеш актуален
            
        Returns:
            Успешность обновления
        """
        # Проверяем, нужно ли обновлять базу
        cache_path = os.path.join(self.cache_dir, 'exploits_db.json')
        if not force and os.path.exists(cache_path):
            # Проверяем время последнего обновления
            cache_time = os.path.getmtime(cache_path)
            if time.time() - cache_time < 24 * 60 * 60:  # 24 часа
                logger.info("База данных эксплойтов актуальна")
                return True
        
        logger.info("Обновление базы данных эксплойтов...")
        
        # В этой версии обновление базы только эмулируется
        # В реальном продукте здесь был бы код для получения данных из Exploit-DB, Metasploit и т.д.
        
        # Демонстрационный код
        try:
            # Сохраняем текущую базу данных как резервную копию
            if os.path.exists(cache_path):
                with open(cache_path, 'r') as f:
                    existing_db = json.load(f)
                backup_path = os.path.join(self.cache_dir, f'exploits_db_backup_{int(time.time())}.json')
                with open(backup_path, 'w') as f:
                    json.dump(existing_db, f, indent=4)
            
            # В реальном коде здесь был бы запрос к репозиториям эксплойтов
            
            # Обновляем кеш
            with open(cache_path, 'w') as f:
                json.dump(self.exploits_db, f, indent=4)
            
            logger.info(f"База данных эксплойтов обновлена. {len(self.exploits_db)} записей.")
            return True
            
        except Exception as e:
            logger.error(f"Ошибка обновления базы данных: {e}")
            return False

# Если запускается как основная программа
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Движок для поиска и запуска эксплойтов")
    parser.add_argument("--target", help="Целевой хост или URL")
    parser.add_argument("--port", type=int, help="Порт (если применимо)")
    parser.add_argument("--cve", help="Поиск эксплойта по CVE")
    parser.add_argument("--service", help="Поиск эксплойта по имени сервиса")
    parser.add_argument("--version", help="Версия сервиса")
    parser.add_argument("--type", choices=["rce", "privilege_escalation", "info_disclosure", "other"],
                      help="Тип эксплойта")
    parser.add_argument("--update", action="store_true", help="Обновить базу данных эксплойтов")
    parser.add_argument("--output", help="Файл для сохранения результатов")
    parser.add_argument("--threads", type=int, default=5, help="Количество потоков")
    parser.add_argument("--timeout", type=int, default=30, help="Таймаут в секундах")
    parser.add_argument("--verbose", action="store_true", help="Подробный вывод")
    parser.add_argument("--safe-mode", action="store_true", help="Безопасный режим (без реального запуска)")
    
    args = parser.parse_args()
    
    # Настраиваем логирование в зависимости от уровня подробности
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Создаем движок эксплойтов
    engine = ExploitEngine(
        threads=args.threads,
        timeout=args.timeout,
        safe_mode=args.safe_mode
    )
    
    # Обновляем базу данных если требуется
    if args.update:
        engine.update_exploits_database(force=True)
    
    # Поиск эксплойтов
    if args.cve or args.service or args.type:
        query = {}
        
        if args.cve:
            query['cve'] = args.cve
        
        if args.service:
            query['service'] = args.service
            
            if args.version:
                query['version'] = args.version
        
        if args.type:
            query['type'] = args.type
        
        exploits = engine.search_exploits(query)
        
        print(f"Найдено {len(exploits)} эксплойтов:")
        for i, exploit in enumerate(exploits, 1):
            print(f"{i}. {exploit.get('id')} - {exploit.get('name')}")
        
        # Если указана цель, запускаем эксплойты
        if args.target and exploits:
            print(f"\nЗапуск эксплойтов против {args.target}:{args.port if args.port else 'N/A'}")
            
            results = engine.run_exploit_batch(
                exploits=exploits,
                target=args.target,
                port=args.port
            )
            
            print("\nРезультаты:")
            for result in results:
                status = "УСПЕШНО" if result['success'] else "НЕУДАЧА"
                print(f"{result['exploit_id']} - {status}")
                if result['error']:
                    print(f"  Ошибка: {result['error']}")
                
                # Сокращаем вывод для удобства
                output_lines = result['output'].split('\n')
                if len(output_lines) > 10:
                    output = '\n'.join(output_lines[:5] + ['...'] + output_lines[-5:])
                else:
                    output = result['output']
                    
                print(f"  Вывод:\n{output}")
            
            # Генерируем отчет
            report = engine.generate_report(results)
            
            print(f"\nИтоги: {report['successful_exploits']} из {report['total_exploits']} эксплойтов успешны")
            
            # Сохраняем результаты если указан файл
            if args.output:
                with open(args.output, 'w') as f:
                    json.dump(report, f, indent=4)
                print(f"Отчет сохранен в {args.output}") 