#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import ipaddress
import json
import logging # Восстанавливаем
import os
import socket
import sys
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, List, Optional, Union, Any, Tuple
# import nmap # Временно комментируем из-за проблем с установкой

# Правильный импорт
from src.host_scanner import HostScanner
from src.port_scanner import PortScanner
from src.web_scanner import WebScanner
from src.service_detector import ServiceDetector
from src.exploit_manager import ExploitManager
from src.report_generator import ReportGenerator

# Настройка логирования
# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
#     handlers=[
#         logging.FileHandler("scanner.log"),
#         logging.StreamHandler()
#     ]
# )
logger = logging.getLogger("VulnerabilityScanner")

class VulnerabilityScanner:
    """
    Главный класс сканера уязвимостей, который координирует работу всех модулей
    """
    
    def __init__(self, target: str = "", output_dir: str = "reports", 
                 threads: int = 10, timeout: int = 5,
                 scan_level: str = "basic"):
        """
        Инициализация сканера уязвимостей
        
        Args:
            target: IP-адрес, доменное имя или диапазон IP (CIDR)
            output_dir: Директория для сохранения отчетов
            threads: Количество потоков для сканирования
            timeout: Таймаут для сетевых операций (в секундах)
            scan_level: Уровень сканирования (basic, advanced, deep)
        """
        self.target = target
        self.output_dir = output_dir
        self.threads = threads
        self.timeout = timeout
        self.scan_level = scan_level
        # Инициализация списка целей, если передан target
        self.targets = self._parse_target(target) if target else []
        
        # Результаты сканирования
        self.results = {
            "metadata": {
                "start_time": "",
                "end_time": "",
                "scan_level": scan_level,
                "targets": self.targets
            },
            "findings": {}
        }
        
        # Создаем директорию для отчетов, если она не существует
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # Инициализируем компоненты
        self.port_scanner = PortScanner(threads=threads, timeout=timeout)
        self.web_scanner = WebScanner(threads=threads, timeout=timeout)
        self.service_detector = ServiceDetector(timeout=timeout)
        self.exploit_manager = ExploitManager()
        self.report_generator = ReportGenerator(output_dir=output_dir)
        
        logger.info(f"Сканер инициализирован для {len(self.targets)} целей с уровнем {scan_level}")
    
    def _parse_target(self, target: str) -> List[str]:
        """
        Парсит цель и возвращает список IP-адресов
        
        Args:
            target: IP-адрес, доменное имя или CIDR
        
        Returns:
            Список IP-адресов для сканирования
        """
        targets = []
        
        # Проверяем, является ли целью CIDR-нотация
        try:
            if '/' in target:
                network = ipaddress.ip_network(target, strict=False)
                targets = [str(ip) for ip in network.hosts()]
                return targets
            
            # Проверяем, является ли целью диапазон IP-адресов (например, 192.168.1.1-192.168.1.10)
            elif '-' in target:
                start_ip, end_ip = target.split('-')
                start_ip = ipaddress.IPv4Address(start_ip.strip())
                end_ip = ipaddress.IPv4Address(end_ip.strip())
                
                current_ip = start_ip
                while current_ip <= end_ip:
                    targets.append(str(current_ip))
                    current_ip += 1
                
                return targets
        except ValueError:
            pass
        
        # Проверяем, является ли целью доменное имя
        try:
            if not target.replace('.', '').isdigit():
                ip = socket.gethostbyname(target)
                targets.append(ip)
                return targets
        except socket.gaierror:
            logger.error(f"Не удалось разрешить доменное имя: {target}")
        
        # Предполагаем, что цель - это один IP-адрес
        try:
            ipaddress.ip_address(target)
            targets.append(target)
        except ValueError:
            logger.error(f"Некорректный формат цели: {target}")
            sys.exit(1)
        
        return targets
    
    def scan(self) -> Dict:
        """
        Запуск полного процесса сканирования
        
        Returns:
            Результаты сканирования в виде словаря
        """
        self.results["metadata"]["start_time"] = time.strftime("%Y-%m-%d %H:%M:%S")
        logger.info("Начало сканирования...")
        
        # Сканируем каждую цель
        for target_ip in self.targets:
            logger.info(f"Сканирование {target_ip}...")
            self.results["findings"][target_ip] = {}
            
            # Шаг 1: Сканирование портов
            open_ports = self.port_scanner.scan(target_ip, self.scan_level)
            self.results["findings"][target_ip]["open_ports"] = open_ports
            
            # Шаг 2: Определение сервисов на открытых портах
            services = {}
            for port in open_ports:
                service_info = self.service_detector.detect_service(target_ip, port)
                services[port] = service_info
            self.results["findings"][target_ip]["services"] = services
            
            # Шаг 3: Сканирование веб-сервисов
            web_ports = [port for port, service in services.items() 
                        if service.get("name", "").lower() in ["http", "https"]]
            
            web_results = {}
            for port in web_ports:
                protocol = "https" if services[port].get("name") == "https" else "http"
                url = f"{protocol}://{target_ip}:{port}"
                web_results[port] = self.web_scanner.scan(url, self.scan_level)
            
            self.results["findings"][target_ip]["web_vulnerabilities"] = web_results
            
            # Шаг 4: Поиск и запуск эксплойтов
            if self.scan_level in ["advanced", "deep"]:
                exploits = self.exploit_manager.find_exploits(services, web_results)
                if exploits:
                    exploit_results = self.exploit_manager.run_exploits(target_ip, exploits)
                    self.results["findings"][target_ip]["exploits"] = exploit_results
        
        self.results["metadata"]["end_time"] = time.strftime("%Y-%m-%d %H:%M:%S")
        logger.info("Сканирование завершено.")
        
        # Генерируем отчеты
        self.report_generator.generate(self.results)
        
        return self.results
    
    def save_results(self, filename: str = None) -> str:
        """
        Сохраняет результаты сканирования в JSON-файл
        
        Args:
            filename: Имя файла для сохранения (без пути)
        
        Returns:
            Полный путь к сохраненному файлу
        """
        if filename is None:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            target_str = self.target.replace('/', '_').replace('.', '_')
            filename = f"scan_{target_str}_{timestamp}.json"
        
        file_path = os.path.join(self.output_dir, filename)
        
        with open(file_path, 'w') as f:
            json.dump(self.results, f, indent=4)
        
        logger.info(f"Результаты сохранены в {file_path}")
        return file_path


def main():
    """
    Основная функция для запуска сканера из командной строки
    """
    parser = argparse.ArgumentParser(description="Сканер уязвимостей")
    parser.add_argument("target", help="IP-адрес, доменное имя или CIDR для сканирования")
    parser.add_argument("-o", "--output", default="reports", help="Директория для сохранения отчетов")
    parser.add_argument("-t", "--threads", type=int, default=10, help="Количество потоков для сканирования")
    parser.add_argument("--timeout", type=int, default=5, help="Таймаут для сетевых операций (в секундах)")
    parser.add_argument("-l", "--level", choices=["basic", "advanced", "deep"], default="basic", 
                      help="Уровень сканирования")
    parser.add_argument("-v", "--verbose", action="store_true", help="Подробный вывод")
    
    args = parser.parse_args()
    
    # Настройка уровня логирования
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Создаем и запускаем сканер
    scanner = VulnerabilityScanner(
        target=args.target,
        output_dir=args.output,
        threads=args.threads,
        timeout=args.timeout,
        scan_level=args.level
    )
    
    results = scanner.scan()
    scanner.save_results()


if __name__ == "__main__":
    main() 