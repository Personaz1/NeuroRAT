#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import time
import logging
import tempfile
from typing import Dict, List, Optional, Any, Tuple, Union

# Импортируем наш движок эксплойтов
from exploit_engine import ExploitEngine

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("exploit_manager.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ExploitManager")

class ExploitManager:
    """
    Менеджер эксплойтов, который интегрируется с модулем сканирования уязвимостей
    и управляет поиском и запуском эксплойтов против обнаруженных целей.
    """
    
    def __init__(self, 
                exploits_dir: str = "exploits",
                cache_dir: str = "cache",
                threads: int = 5,
                timeout: int = 30,
                safe_mode: bool = True):
        """
        Инициализация менеджера эксплойтов
        
        Args:
            exploits_dir: Директория с локальными эксплойтами
            cache_dir: Директория для кеширования данных
            threads: Количество потоков для параллельного запуска эксплойтов
            timeout: Таймаут для выполнения эксплойта (в секундах)
            safe_mode: Безопасный режим (без реального запуска эксплойтов)
        """
        # Инициализируем движок эксплойтов
        self.engine = ExploitEngine(
            exploits_dir=exploits_dir,
            cache_dir=cache_dir,
            threads=threads,
            timeout=timeout,
            safe_mode=safe_mode
        )
        
        # Настройки
        self.exploits_dir = exploits_dir
        self.cache_dir = cache_dir
        self.threads = threads
        self.timeout = timeout
        self.safe_mode = safe_mode
        
        # Кеш результатов
        self.results_cache = {}
        
        logger.info("ExploitManager инициализирован")
    
    def find_exploits(self, 
                     services: Dict[int, Dict[str, Any]], 
                     vulnerabilities: Dict[int, Dict[str, Any]]) -> Dict[int, List[Dict[str, Any]]]:
        """
        Ищет подходящие эксплойты для обнаруженных сервисов и уязвимостей
        
        Args:
            services: Словарь с информацией о сервисах (ключ - порт)
            vulnerabilities: Словарь с информацией о уязвимостях (ключ - порт)
        
        Returns:
            Словарь с эксплойтами для каждого порта
        """
        logger.info(f"Поиск эксплойтов для {len(services)} сервисов и {len(vulnerabilities)} уязвимостей")
        
        # Словарь для результатов: порт -> список эксплойтов
        exploits_map = {}
        
        # Сначала ищем эксплойты для обнаруженных уязвимостей (более точное совпадение)
        for port, vuln_list in vulnerabilities.items():
            if not isinstance(vuln_list, list):
                continue
                
            exploits_for_port = []
            
            for vuln in vuln_list:
                # Ищем эксплойты для уязвимости
                matching_exploits = self.engine.find_exploits_for_vulnerability(vuln)
                if matching_exploits:
                    # Добавляем уникальные эксплойты
                    for exploit in matching_exploits:
                        if exploit not in exploits_for_port:
                            exploits_for_port.append(exploit)
            
            if exploits_for_port:
                exploits_map[port] = exploits_for_port
        
        # Затем ищем эксплойты для обнаруженных сервисов (менее точное совпадение)
        for port, service_info in services.items():
            if port not in exploits_map:
                exploits_map[port] = []
            
            # Ищем эксплойты для сервиса
            matching_exploits = self.engine.find_exploits_for_service(service_info)
            
            # Добавляем уникальные эксплойты
            for exploit in matching_exploits:
                if exploit not in exploits_map[port]:
                    exploits_map[port].append(exploit)
        
        # Убираем порты без эксплойтов
        exploits_map = {k: v for k, v in exploits_map.items() if v}
        
        # Логируем результаты
        total_exploits = sum(len(exploits) for exploits in exploits_map.values())
        logger.info(f"Найдено {total_exploits} эксплойтов для {len(exploits_map)} портов")
        
        return exploits_map
    
    def run_exploits(self, 
                    target: str, 
                    exploits_map: Dict[int, List[Dict[str, Any]]],
                    max_exploits_per_port: int = 5) -> Dict[int, List[Dict[str, Any]]]:
        """
        Запускает найденные эксплойты против указанной цели
        
        Args:
            target: Целевой хост или URL
            exploits_map: Словарь с эксплойтами для каждого порта
            max_exploits_per_port: Максимальное количество эксплойтов для запуска на порт
            
        Returns:
            Словарь с результатами для каждого порта
        """
        logger.info(f"Запуск эксплойтов против {target} на {len(exploits_map)} портах")
        
        # Словарь для результатов: порт -> список результатов
        results_map = {}
        
        # Запускаем эксплойты для каждого порта
        for port, exploits in exploits_map.items():
            logger.info(f"Запуск эксплойтов для порта {port} ({len(exploits)} найдено)")
            
            # Ограничиваем количество эксплойтов для запуска
            if len(exploits) > max_exploits_per_port:
                logger.warning(f"Слишком много эксплойтов для порта {port}, ограничиваем до {max_exploits_per_port}")
                # Сортируем по вероятности успеха (в реальном коде здесь была бы более сложная логика)
                exploits = sorted(exploits, key=lambda x: x.get('relevance', 0), reverse=True)[:max_exploits_per_port]
            
            # Запускаем эксплойты пакетом
            results = self.engine.run_exploit_batch(
                exploits=exploits,
                target=target,
                port=port
            )
            
            # Сохраняем результаты
            results_map[port] = results
            
            # Если хотя бы один эксплойт успешен, прекращаем запуск для этого порта
            if any(r['success'] for r in results):
                logger.info(f"Найден успешный эксплойт для порта {port}")
        
        # Сохраняем в кеш
        cache_key = f"{target}_{int(time.time())}"
        self.results_cache[cache_key] = results_map
        
        # Логируем общие результаты
        successful_ports = sum(1 for port, results in results_map.items() if any(r['success'] for r in results))
        logger.info(f"Успешно эксплуатировано {successful_ports} из {len(results_map)} портов")
        
        return results_map
    
    def generate_exploitation_report(self, results_map: Dict[int, List[Dict[str, Any]]]) -> Dict[str, Any]:
        """
        Генерирует отчет о результатах эксплуатации
        
        Args:
            results_map: Словарь с результатами для каждого порта
            
        Returns:
            Отчет в виде словаря
        """
        # Собираем статистику
        total_exploits = sum(len(results) for results in results_map.values())
        successful_exploits = sum(sum(1 for r in results if r['success']) for results in results_map.values())
        
        # Порты, для которых удалось найти успешный эксплойт
        successful_ports = [port for port, results in results_map.items() if any(r['success'] for r in results)]
        
        # Все успешные эксплойты
        all_successful = []
        for port, results in results_map.items():
            for result in results:
                if result['success']:
                    all_successful.append({
                        'port': port,
                        **result
                    })
        
        # Формируем отчет
        report = {
            'timestamp': time.time(),
            'total_exploits': total_exploits,
            'successful_exploits': successful_exploits,
            'success_rate': successful_exploits / total_exploits if total_exploits else 0,
            'successful_ports': successful_ports,
            'successful_details': all_successful,
            'full_results': results_map
        }
        
        return report
    
    def get_most_recent_result(self, target: str) -> Optional[Dict[int, List[Dict[str, Any]]]]:
        """
        Возвращает самый свежий результат для указанной цели
        
        Args:
            target: Целевой хост или URL
            
        Returns:
            Словарь с результатами или None если нет данных
        """
        # Фильтруем кеш по цели
        target_results = {k: v for k, v in self.results_cache.items() if k.startswith(f"{target}_")}
        
        if not target_results:
            return None
        
        # Сортируем по времени (ключ содержит timestamp)
        sorted_keys = sorted(target_results.keys(), reverse=True)
        return target_results[sorted_keys[0]]
    
    def save_report(self, report: Dict[str, Any], filename: str = None) -> str:
        """
        Сохраняет отчет в файл
        
        Args:
            report: Отчет для сохранения
            filename: Имя файла (по умолчанию генерируется автоматически)
            
        Returns:
            Путь к сохраненному файлу
        """
        if filename is None:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"exploit_report_{timestamp}.json"
        
        # Создаем директорию reports если не существует
        reports_dir = "reports"
        if not os.path.exists(reports_dir):
            os.makedirs(reports_dir)
        
        # Полный путь к файлу
        file_path = os.path.join(reports_dir, filename)
        
        # Сохраняем отчет
        with open(file_path, 'w') as f:
            json.dump(report, f, indent=4)
        
        logger.info(f"Отчет сохранен в {file_path}")
        return file_path
    
    def find_and_run_exploits_for_target(self, 
                                       target: str, 
                                       scan_results: Dict[str, Any],
                                       max_exploits_per_port: int = 5) -> Dict[str, Any]:
        """
        Комплексная функция для поиска и запуска эксплойтов на основе результатов сканирования
        
        Args:
            target: Целевой хост
            scan_results: Результаты сканирования (должны содержать services и vulnerabilities)
            max_exploits_per_port: Максимальное количество эксплойтов для запуска на порт
            
        Returns:
            Отчет о эксплуатации
        """
        logger.info(f"Поиск и запуск эксплойтов для {target}")
        
        # Извлекаем данные о сервисах и уязвимостях
        services = scan_results.get('services', {})
        vulnerabilities = scan_results.get('web_vulnerabilities', {})
        
        # Ищем эксплойты
        exploits_map = self.find_exploits(services, vulnerabilities)
        
        if not exploits_map:
            logger.warning(f"Не найдено подходящих эксплойтов для {target}")
            return {
                'timestamp': time.time(),
                'target': target,
                'total_exploits': 0,
                'successful_exploits': 0,
                'success_rate': 0,
                'message': "Не найдено подходящих эксплойтов"
            }
        
        # Запускаем эксплойты
        results_map = self.run_exploits(
            target=target,
            exploits_map=exploits_map,
            max_exploits_per_port=max_exploits_per_port
        )
        
        # Генерируем отчет
        report = self.generate_exploitation_report(results_map)
        report['target'] = target
        
        # Сохраняем отчет
        self.save_report(report)
        
        return report


# Если запускается как основная программа
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Менеджер эксплойтов для уязвимостей")
    parser.add_argument("--target", required=True, help="Целевой хост или URL")
    parser.add_argument("--scan-results", help="Путь к файлу с результатами сканирования")
    parser.add_argument("--port", type=int, help="Конкретный порт для атаки (необязательно)")
    parser.add_argument("--max-exploits", type=int, default=5, 
                      help="Максимальное количество эксплойтов на порт")
    parser.add_argument("--output", help="Путь для сохранения отчета")
    parser.add_argument("--safe-mode", action="store_true", default=True,
                      help="Безопасный режим без реального запуска эксплойтов")
    parser.add_argument("--force", action="store_true",
                      help="Принудительный запуск даже в безопасном режиме")
    parser.add_argument("--verbose", action="store_true", help="Подробный вывод")
    
    args = parser.parse_args()
    
    # Настраиваем уровень логирования
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Предупреждение для небезопасного режима
    if not args.safe_mode or args.force:
        logger.warning("ВНИМАНИЕ: Запуск в небезопасном режиме. Эксплойты будут реально выполнены!")
        confirm = input("Вы уверены, что хотите продолжить? (y/N): ")
        if confirm.lower() != 'y':
            logger.info("Операция отменена пользователем")
            sys.exit(0)
    
    # Создаем менеджер эксплойтов
    manager = ExploitManager(
        safe_mode=args.safe_mode and not args.force
    )
    
    # Загружаем результаты сканирования если указаны
    scan_results = {}
    if args.scan_results:
        with open(args.scan_results, 'r') as f:
            scan_results = json.load(f)
        
        # Запускаем комплексный поиск и эксплуатацию
        report = manager.find_and_run_exploits_for_target(
            target=args.target,
            scan_results=scan_results,
            max_exploits_per_port=args.max_exploits
        )
    else:
        # Если порт указан, создаем dummy-данные для этого порта
        if args.port:
            services = {
                args.port: {
                    'name': 'unknown',
                    'version': ''
                }
            }
            vulnerabilities = {}
            
            # Ищем эксплойты
            exploits_map = manager.find_exploits(services, vulnerabilities)
            
            if not exploits_map:
                logger.warning(f"Не найдено подходящих эксплойтов для {args.target}:{args.port}")
                sys.exit(1)
            
            # Запускаем эксплойты
            results_map = manager.run_exploits(
                target=args.target,
                exploits_map=exploits_map,
                max_exploits_per_port=args.max_exploits
            )
            
            # Генерируем отчет
            report = manager.generate_exploitation_report(results_map)
        else:
            logger.error("Необходимо указать либо файл с результатами сканирования, либо конкретный порт")
            sys.exit(1)
    
    # Сохраняем отчет если указан выходной файл
    if args.output:
        manager.save_report(report, args.output)
    
    # Выводим результаты
    print(f"\nИтоги эксплуатации {args.target}:")
    print(f"- Всего найдено эксплойтов: {report['total_exploits']}")
    print(f"- Успешно выполнено: {report['successful_exploits']} (успешность: {report['success_rate']:.2%})")
    
    if report['successful_exploits'] > 0:
        print("\nУспешные эксплойты:")
        for exploit in report.get('successful_details', []):
            print(f"- Порт {exploit['port']}: {exploit['exploit_id']} - {exploit['exploit_name']}")
    else:
        print("\nНе удалось успешно эксплуатировать ни одну уязвимость.") 